### Day 13

[104. äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

ã€æ€è·¯1â€”â€”å±‚åºéå†å®ƒæ±‚æ·±åº¦ä¸€ç›´å¯ä»¥çš„ğŸ™‚ã€‘

ã€C++ä»£ç ã€‘

```c++
int maxDepth(TreeNode* root) {
    if(!root)  return 0;
    int d = 0;
    queue<TreeNode*> que;
    que.push(root);

    while(!que.empty()) {
        int size = que.size();
        while(size--) {
            TreeNode* cur = que.front();
            que.pop();

            if(cur->left)  que.push(cur->left);
            if(cur->right)  que.push(cur->right);
        }
        d++;
    }

    return d;
}
```

æ—¶é—´å¤æ‚åº¦ï¼š $O(n)$

ç©ºé—´å¤æ‚åº¦ï¼š æœ€åæƒ…å†µä¸‹$O(2^h-1)=O(n)$ï¼Œå…¶ä¸­$h$ä¸ºäºŒå‰æ ‘çš„é«˜åº¦

ã€æ€è·¯2â€”â€”é€’å½’ã€‘

äºŒå‰æ ‘çš„æ·±åº¦ç­‰äº `maxï¼ˆå·¦å­æ ‘çš„æ·±åº¦ï¼Œå³å­æ ‘çš„æ·±åº¦ï¼‰+ 1` ï¼Œé€’å½’åœ°è®¡ç®—å­æ ‘çš„æ·±åº¦å³å¯ã€‚

ã€C++ä»£ç ã€‘

```c++
int maxDepth(TreeNode* root) {
    if(!root)  return 0;
    return max(maxDepth(root->left), maxDepth(root->right)) + 1;
}
```

æ—¶é—´å¤æ‚åº¦ï¼š $O(n)$

ç©ºé—´å¤æ‚åº¦ï¼š $O(\log n)$

### Day 14

[100. ç›¸åŒçš„æ ‘](https://leetcode-cn.com/problems/same-tree/)

ã€æ€è·¯1â€”â€”é€’å½’ã€‘

è‹¥ä¸¤ä¸ªæ ‘ç›¸åŒï¼Œåˆ™æ ¹èŠ‚ç‚¹ç›¸åŒï¼Œä¸”å·¦å³å­æ ‘åˆ†åˆ«ç›¸åŒã€‚

```c++
bool isSameTree(TreeNode* p, TreeNode* q) {
    if(!p && !q)  return true;
    else if(!p && q || p && !q)  return false;
    else if(p->val != q->val)  return false;

    return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);
}
```

æ—¶é—´å¤æ‚åº¦ï¼š $O(n)$

ç©ºé—´å¤æ‚åº¦ï¼š è€ƒè™‘é€’å½’å‡½æ•°çš„å¼€é”€å°±æ˜¯$O(\log n)$

ã€æ€è·¯2â€”â€”è¿­ä»£ã€‘

ä¸Šé¢çš„é€’å½’å†™æ³•æ˜¯äºŒå‰æ ‘çš„å‰åºéå†ï¼Œè‡ªç„¶å¯ä»¥å†™æˆè¿­ä»£çš„å½¢å¼ï¼›è¿™é‡Œå†™æˆå‰åºéå†æˆ–è€…å±‚åºéå†éƒ½å¯ä»¥ã€‚

```c++
bool isSameTree(TreeNode* p, TreeNode* q) {
    if(!p && !q)  return true;
    stack<TreeNode*> stk;
    stk.push(p);
    stk.push(q);

    while(!stk.empty()){
        TreeNode* qNode = stk.top();
        stk.pop();
        TreeNode* pNode = stk.top();
        stk.pop();

        if(!qNode && !pNode)  continue;
        if(!qNode || !pNode || pNode->val != qNode->val)  return false;

        stk.push(pNode->right);
        stk.push(qNode->right);
        stk.push(pNode->left);
        stk.push(qNode->left);
    }

    return true;
}
```

æ—¶é—´å¤æ‚åº¦ï¼š $O(n)$

ç©ºé—´å¤æ‚åº¦ï¼š $O(n)$

### Day 15

[129. æ±‚æ ¹èŠ‚ç‚¹åˆ°å¶èŠ‚ç‚¹æ•°å­—ä¹‹å’Œ](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/)


ã€æ€è·¯1â€”â€”DFSã€‘

ç”¨DFSçš„æ–¹æ³•å»æ‰¾æ¯ä¸€ä¸ªè·¯å¾„ï¼Œå¯ä»¥ç”¨stringæ¥ä¿å­˜è·¯å¾„ï¼Œé‡åˆ°å¶å­èŠ‚ç‚¹å°±ç”¨`stoi()`å‡½æ•°å°†stringè½¬æ¢æˆintåŠ åˆ°ç­”æ¡ˆä¸Šé¢ã€‚

ã€C++ä»£ç ã€‘

```c++
class Solution {
public:
    int res = 0;
    void dfs(TreeNode* root, const string& path){
        if(!root->left && !root->right) {
            res += stoi(path);
            return;
        }

        if(root->left)
            dfs(root->left, path + to_string(root->left->val));
            
        if(root->right)
            dfs(root->right, path + to_string(root->right->val));
    }
    int sumNumbers(TreeNode* root) {
        string path = to_string(root->val);
        dfs(root, path);
        return res;
    }
};
```

æ—¶é—´å¤æ‚åº¦ï¼š $O(n)$ï¼›ç©ºé—´å¤æ‚åº¦ï¼š $O(\log n)$

æœ¬é¢˜ä¸­èŠ‚ç‚¹ä¸Šçš„æ•°å­—ä»…ä»…æ˜¯ä¸ªä½æ•°ï¼Œæ‰€ä»¥åœ¨ä¿å­˜è·¯å¾„æ—¶ä¸ç”¨è¿™ä¹ˆéº»çƒ¦ï¼Œç›´æ¥ç”¨ `prevSum * 10 + root->val` å³å¯ã€‚

```c++
class Solution {
public:
    int dfs(TreeNode* root, int prevSum) {
        if(!root) {
            return 0;
        }
        
        int sum = prevSum * 10 + root->val;
        if(!root->left && !root->right) {
            return sum;
        }
        else {
            return dfs(root->left, sum) + dfs(root->right, sum);
        }
    }
    int sumNumbers(TreeNode* root) {
        return dfs(root, 0);
    }
};
```

æ—¶é—´å¤æ‚åº¦ï¼š $O(n)$ï¼›ç©ºé—´å¤æ‚åº¦ï¼š $O(\log n)$


