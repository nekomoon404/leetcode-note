### Day 13

[104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

【思路1——层序遍历它求深度一直可以的🙂】

【C++代码】

```c++
int maxDepth(TreeNode* root) {
    if(!root)  return 0;
    int d = 0;
    queue<TreeNode*> que;
    que.push(root);

    while(!que.empty()) {
        int size = que.size();
        while(size--) {
            TreeNode* cur = que.front();
            que.pop();

            if(cur->left)  que.push(cur->left);
            if(cur->right)  que.push(cur->right);
        }
        d++;
    }

    return d;
}
```

时间复杂度： $O(n)$

空间复杂度： 最坏情况下$O(2^h-1)=O(n)$，其中$h$为二叉树的高度

【思路2——递归】

二叉树的深度等于 `max（左子树的深度，右子树的深度）+ 1` ，递归地计算子树的深度即可。

【C++代码】

```c++
int maxDepth(TreeNode* root) {
    if(!root)  return 0;
    return max(maxDepth(root->left), maxDepth(root->right)) + 1;
}
```

时间复杂度： $O(n)$

空间复杂度： $O(\log n)$

### Day 14

[100. 相同的树](https://leetcode-cn.com/problems/same-tree/)

【思路1——递归】

若两个树相同，则根节点相同，且左右子树分别相同。

```c++
bool isSameTree(TreeNode* p, TreeNode* q) {
    if(!p && !q)  return true;
    else if(!p && q || p && !q)  return false;
    else if(p->val != q->val)  return false;

    return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);
}
```

时间复杂度： $O(n)$

空间复杂度： 考虑递归函数的开销就是$O(\log n)$

【思路2——迭代】

上面的递归写法是二叉树的前序遍历，自然可以写成迭代的形式；这里写成前序遍历或者层序遍历都可以。

```c++
bool isSameTree(TreeNode* p, TreeNode* q) {
    if(!p && !q)  return true;
    stack<TreeNode*> stk;
    stk.push(p);
    stk.push(q);

    while(!stk.empty()){
        TreeNode* qNode = stk.top();
        stk.pop();
        TreeNode* pNode = stk.top();
        stk.pop();

        if(!qNode && !pNode)  continue;
        if(!qNode || !pNode || pNode->val != qNode->val)  return false;

        stk.push(pNode->right);
        stk.push(qNode->right);
        stk.push(pNode->left);
        stk.push(qNode->left);
    }

    return true;
}
```

时间复杂度： $O(n)$

空间复杂度： $O(n)$

### Day 15

[129. 求根节点到叶节点数字之和](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/)


【思路1——DFS】

用DFS的方法去找每一个路径，可以用string来保存路径，遇到叶子节点就用`stoi()`函数将string转换成int加到答案上面。

【C++代码】

```c++
class Solution {
public:
    int res = 0;
    void dfs(TreeNode* root, const string& path){
        if(!root->left && !root->right) {
            res += stoi(path);
            return;
        }

        if(root->left)
            dfs(root->left, path + to_string(root->left->val));
            
        if(root->right)
            dfs(root->right, path + to_string(root->right->val));
    }
    int sumNumbers(TreeNode* root) {
        string path = to_string(root->val);
        dfs(root, path);
        return res;
    }
};
```

时间复杂度： $O(n)$；空间复杂度： $O(\log n)$

本题中节点上的数字仅仅是个位数，所以在保存路径时不用这么麻烦，直接用 `prevSum * 10 + root->val` 即可。

```c++
class Solution {
public:
    int dfs(TreeNode* root, int prevSum) {
        if(!root) {
            return 0;
        }
        
        int sum = prevSum * 10 + root->val;
        if(!root->left && !root->right) {
            return sum;
        }
        else {
            return dfs(root->left, sum) + dfs(root->right, sum);
        }
    }
    int sumNumbers(TreeNode* root) {
        return dfs(root, 0);
    }
};
```

时间复杂度： $O(n)$；空间复杂度： $O(\log n)$

### Day 16

[513. 找树左下角的值
](https://leetcode-cn.com/problems/find-bottom-left-tree-value/)

【思路1——BFS】

层序遍历它解决深度相关的问题一直可以的。

【C++代码】

```c++
int findBottomLeftValue(TreeNode* root) {
    queue<TreeNode*> que;
    que.push(root);
    int res = root->val;
    
    while(!que.empty()){
        res = que.front()->val;
        int size = que.size();
        while(size--) {
            TreeNode* cur = que.front();
            que.pop();
            if(cur->left)  que.push(cur->left);
            if(cur->right)  que.push(cur->right);
        }
    }

    return res;
}
```

时间复杂度： $O(n)$，遍历一次所有的节点

空间复杂度： $O(n)$，与队列的长度成正比，最坏情况下是满二叉树，最后一层的节点数量是 $n/2$


