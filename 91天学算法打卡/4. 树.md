### Day 13

[104. äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

ã€æ€è·¯1â€”â€”å±‚åºéå†å®ƒæ±‚æ·±åº¦ä¸€ç›´å¯ä»¥çš„ğŸ™‚ã€‘

ã€C++ä»£ç ã€‘

```c++
int maxDepth(TreeNode* root) {
    if(!root)  return 0;
    int d = 0;
    queue<TreeNode*> que;
    que.push(root);

    while(!que.empty()) {
        int size = que.size();
        while(size--) {
            TreeNode* cur = que.front();
            que.pop();

            if(cur->left)  que.push(cur->left);
            if(cur->right)  que.push(cur->right);
        }
        d++;
    }

    return d;
}
```

æ—¶é—´å¤æ‚åº¦ï¼š $O(n)$

ç©ºé—´å¤æ‚åº¦ï¼š æœ€åæƒ…å†µä¸‹$O(2^h-1)=O(n)$ï¼Œå…¶ä¸­$h$ä¸ºäºŒå‰æ ‘çš„é«˜åº¦

ã€æ€è·¯2â€”â€”é€’å½’ã€‘

äºŒå‰æ ‘çš„æ·±åº¦ç­‰äº `maxï¼ˆå·¦å­æ ‘çš„æ·±åº¦ï¼Œå³å­æ ‘çš„æ·±åº¦ï¼‰+ 1` ï¼Œé€’å½’åœ°è®¡ç®—å­æ ‘çš„æ·±åº¦å³å¯ã€‚

ã€C++ä»£ç ã€‘

```c++
int maxDepth(TreeNode* root) {
    if(!root)  return 0;
    return max(maxDepth(root->left), maxDepth(root->right)) + 1;
}
```

æ—¶é—´å¤æ‚åº¦ï¼š $O(n)$

ç©ºé—´å¤æ‚åº¦ï¼š $O(\log n)$

### Day 14

[100. ç›¸åŒçš„æ ‘](https://leetcode-cn.com/problems/same-tree/)

ã€æ€è·¯1â€”â€”é€’å½’ã€‘

è‹¥ä¸¤ä¸ªæ ‘ç›¸åŒï¼Œåˆ™æ ¹èŠ‚ç‚¹ç›¸åŒï¼Œä¸”å·¦å³å­æ ‘åˆ†åˆ«ç›¸åŒã€‚

```c++
bool isSameTree(TreeNode* p, TreeNode* q) {
    if(!p && !q)  return true;
    else if(!p && q || p && !q)  return false;
    else if(p->val != q->val)  return false;

    return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);
}
```

æ—¶é—´å¤æ‚åº¦ï¼š $O(n)$

ç©ºé—´å¤æ‚åº¦ï¼š è€ƒè™‘é€’å½’å‡½æ•°çš„å¼€é”€å°±æ˜¯$O(\log n)$

ã€æ€è·¯2â€”â€”è¿­ä»£ã€‘

ä¸Šé¢çš„é€’å½’å†™æ³•æ˜¯äºŒå‰æ ‘çš„å‰åºéå†ï¼Œè‡ªç„¶å¯ä»¥å†™æˆè¿­ä»£çš„å½¢å¼ï¼›è¿™é‡Œå†™æˆå‰åºéå†æˆ–è€…å±‚åºéå†éƒ½å¯ä»¥ã€‚

```c++
bool isSameTree(TreeNode* p, TreeNode* q) {
    if(!p && !q)  return true;
    stack<TreeNode*> stk;
    stk.push(p);
    stk.push(q);

    while(!stk.empty()){
        TreeNode* qNode = stk.top();
        stk.pop();
        TreeNode* pNode = stk.top();
        stk.pop();

        if(!qNode && !pNode)  continue;
        if(!qNode || !pNode || pNode->val != qNode->val)  return false;

        stk.push(pNode->right);
        stk.push(qNode->right);
        stk.push(pNode->left);
        stk.push(qNode->left);
    }

    return true;
}
```

æ—¶é—´å¤æ‚åº¦ï¼š $O(n)$

ç©ºé—´å¤æ‚åº¦ï¼š $O(n)$

### Day 15

[129. æ±‚æ ¹èŠ‚ç‚¹åˆ°å¶èŠ‚ç‚¹æ•°å­—ä¹‹å’Œ](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/)


ã€æ€è·¯1â€”â€”DFSã€‘

ç”¨DFSçš„æ–¹æ³•å»æ‰¾æ¯ä¸€ä¸ªè·¯å¾„ï¼Œå¯ä»¥ç”¨stringæ¥ä¿å­˜è·¯å¾„ï¼Œé‡åˆ°å¶å­èŠ‚ç‚¹å°±ç”¨`stoi()`å‡½æ•°å°†stringè½¬æ¢æˆintåŠ åˆ°ç­”æ¡ˆä¸Šé¢ã€‚

ã€C++ä»£ç ã€‘

```c++
class Solution {
public:
    int res = 0;
    void dfs(TreeNode* root, const string& path){
        if(!root->left && !root->right) {
            res += stoi(path);
            return;
        }

        if(root->left)
            dfs(root->left, path + to_string(root->left->val));
            
        if(root->right)
            dfs(root->right, path + to_string(root->right->val));
    }
    int sumNumbers(TreeNode* root) {
        string path = to_string(root->val);
        dfs(root, path);
        return res;
    }
};
```

æ—¶é—´å¤æ‚åº¦ï¼š $O(n)$ï¼›ç©ºé—´å¤æ‚åº¦ï¼š $O(\log n)$

æœ¬é¢˜ä¸­èŠ‚ç‚¹ä¸Šçš„æ•°å­—ä»…ä»…æ˜¯ä¸ªä½æ•°ï¼Œæ‰€ä»¥åœ¨ä¿å­˜è·¯å¾„æ—¶ä¸ç”¨è¿™ä¹ˆéº»çƒ¦ï¼Œç›´æ¥ç”¨ `prevSum * 10 + root->val` å³å¯ã€‚

```c++
class Solution {
public:
    int dfs(TreeNode* root, int prevSum) {
        if(!root) {
            return 0;
        }
        
        int sum = prevSum * 10 + root->val;
        if(!root->left && !root->right) {
            return sum;
        }
        else {
            return dfs(root->left, sum) + dfs(root->right, sum);
        }
    }
    int sumNumbers(TreeNode* root) {
        return dfs(root, 0);
    }
};
```

æ—¶é—´å¤æ‚åº¦ï¼š $O(n)$ï¼›ç©ºé—´å¤æ‚åº¦ï¼š $O(\log n)$

### Day 16

[513. æ‰¾æ ‘å·¦ä¸‹è§’çš„å€¼
](https://leetcode-cn.com/problems/find-bottom-left-tree-value/)

ã€æ€è·¯1â€”â€”BFSã€‘

å±‚åºéå†å®ƒè§£å†³æ·±åº¦ç›¸å…³çš„é—®é¢˜ä¸€ç›´å¯ä»¥çš„ã€‚

ã€C++ä»£ç ã€‘

```c++
int findBottomLeftValue(TreeNode* root) {
    queue<TreeNode*> que;
    que.push(root);
    int res = root->val;
    
    while(!que.empty()){
        res = que.front()->val;
        int size = que.size();
        while(size--) {
            TreeNode* cur = que.front();
            que.pop();
            if(cur->left)  que.push(cur->left);
            if(cur->right)  que.push(cur->right);
        }
    }

    return res;
}
```

æ—¶é—´å¤æ‚åº¦ï¼š $O(n)$ï¼Œéå†ä¸€æ¬¡æ‰€æœ‰çš„èŠ‚ç‚¹

ç©ºé—´å¤æ‚åº¦ï¼š $O(n)$ï¼Œä¸é˜Ÿåˆ—çš„é•¿åº¦æˆæ­£æ¯”ï¼Œæœ€åæƒ…å†µä¸‹æ˜¯æ»¡äºŒå‰æ ‘ï¼Œæœ€åä¸€å±‚çš„èŠ‚ç‚¹æ•°é‡æ˜¯ $n/2$

### Day 17

[297. äºŒå‰æ ‘çš„åºåˆ—åŒ–ä¸ååºåˆ—åŒ–](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)

ã€æ€è·¯â€”â€”DFSã€‘

åºåˆ—åŒ–ï¼šäºŒå‰æ ‘åºåˆ—åŒ–çš„æ–¹æ³•æœ‰å¾ˆå¤šï¼ŒåŸºæœ¬ä¸Šæ˜¯åŸºäºæ ‘çš„éå†ï¼Œè¿™é‡Œä½¿ç”¨å‰åºéå†ï¼Œéå†æ—¶ä¸€å®šè¦æŠŠç©ºèŠ‚ç‚¹å­˜ä¸‹æ¥ï¼Œå› ä¸º**è‹¥ä¸å­˜ç©ºèŠ‚ç‚¹ï¼Œå•é å‰åºéå†åºåˆ—æ˜¯æ— æ³•è¿˜åŸå‡ºäºŒå‰æ ‘çš„ï¼Œ** éœ€è¦å‰åºéå†+ä¸­åºéå†æ‰èƒ½è¿˜åŸå‡ºäºŒå‰æ ‘**ã€‚**

ååºåˆ—åŒ–ï¼šä»å‰åºåºåˆ—ä¸­è¿˜åŸå‡ºäºŒå‰æ ‘ï¼Œç”¨ä¸€ä¸ªæŒ‡é’ˆ u è®°å½•éå†åˆ°å‰åºåºåˆ—ä¸­çš„ç¬¬å‡ ä¸ªæ•°äº†ï¼Œå’ŒLC105ï¼Œ106çš„æ€è·¯ä¸€æ ·ï¼Œä¿è¯æ€»æ˜¯å…ˆæ„é€ å·¦å­æ ‘ï¼Œå†æ„é€ å³å­æ ‘ï¼Œè¿™æ ·å°±å¯ä»¥ç”¨ä¸€ä¸ªæŒ‡é’ˆæ¥è·Ÿè¸ªå»ºæ ‘çš„è¿‡ç¨‹äº†ã€‚

ã€C++ä»£ç ã€‘

```c++
class Codec {
private:
    string path;
    void dfs_s(TreeNode* root) {
        if(!root)  path += "#,";   // æ³¨æ„è¿™é‡Œè¦åŠ åŒå¼•å·
        else {
            path += to_string(root->val) + ',';   //to_string æŠŠæ•°å­—è½¬åŒ–ä¸ºå­—ç¬¦ä¸²ï¼Œæ¯ä¸€ä½æ•°å­—å ä¸€ä¸ªchar
            dfs_s(root->left);
            dfs_s(root->right);
        }
    }

    TreeNode* dfs_d(const string& data, int& u) {
        if(data[u] == '#') {
            u += 2;   //è¦è·³è¿‡ # å’Œ ,
            return nullptr;
        }
        else {
            int k = u;
            while(data[u] != ',')  u ++;    //å¾ªç¯ç»“æŸæ—¶ï¼Œu æŒ‡å‘é€—å·
            TreeNode* root = new TreeNode(stoi(data.substr(k, u - k)));  //è¦æŠŠè¿ç»­çš„æ•°å­—å­—ç¬¦è½¬åŒ–ä¸ºç›¸åº”çš„æ•´å‹æ•°
            u ++;  //è¦è·³è¿‡é€—å·',' 
            root->left = dfs_d(data, u);
            root->right = dfs_d(data, u);
            return root;
        }
    }
public:

    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        dfs_s(root);
        return path;
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        int u = 0;
        return dfs_d(data, u);
    }
};
```

æ—¶é—´å¤æ‚åº¦ï¼š $O(n)$ï¼Œéå†ä¸€æ¬¡æ ‘ä¸­çš„èŠ‚ç‚¹ï¼›

ç©ºé—´å¤æ‚åº¦ï¼š $O(h)$ï¼Œå‡½æ•°é€’å½’çš„æ·±åº¦ä¸æ ‘çš„é«˜åº¦æˆæ­£æ¯”ï¼Œæœ€åæƒ…å†µä¸‹æ ‘é«˜æ˜¯$n$ã€‚

